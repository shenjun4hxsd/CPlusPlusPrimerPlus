##堆排序

```javascript
//
//  CSort.cpp
//  Lesson5
//
//  Created by ShenJun on 2017/1/19.
//  Copyright © 2017年 ShenJun. All rights reserved.
//

#include "CSort.hpp"



NS_BEGIN

void Swap(int& a, int&b)
{
    a ^= b;
    b ^= a;
    a ^= b;
}

// 插入排序
void InsertOrder()
{
    using namespace std;
    
    vector<int> p1; // 原始数据的链表
    vector<int> p2; // 排序的链表
    
    srand((int)time(0)); // 设置种子
    
    for (int i = 0; i < 5; i++) {
        p1.push_back(rand()%10);
    }
    
    for (int i = 0; i < p1.size(); i++) {
        if(p2.empty())
        {
            p2.push_back(p1[i]);
        }
        else
        {
            for (int j = 0; j < p2.size(); j++) {
                if(p1[i] < p2[j])
                {
                    p2.insert(p2.begin()+j, p1[i]);
                    break;
                }
                else
                {
                    if(j == p2.size()-1)
                    {
                        p2.push_back(p1[i]);
                        break;
                    }
                }
            }
        }
    }
    
    for (vector<int>::iterator it = p2.begin(); it != p2.end(); it++) {
        std::cout << *it << std::endl;
    }

}

// 冒泡排序
void BubbleOrder()
{
    const int nCount = 9;
    int data[nCount] {3, 5, 9, 2, 8, 5, 7, 2, 1};
    
    for (int i = 0; i < nCount; i++) {
        for (int j = nCount - 1; j > i; j--) {
            if(data[j] < data[j - 1])
            {
                Swap(data[j], data[j-1]);
            }
        }
    }
    
    for (int i = 0; i < nCount; i++) {
        std::cout << data[i] << std::endl;
    }
}

// 交换法排序
void ExchangeOrder()
{
    const int nCount = 9;
    int data[nCount] {3, 5, 9, 2, 8, 5, 7, 2, 1};
    
    for (int i = 0; i < nCount; i++) {
        for (int j = i + 1; j < nCount; j++) {
            if(data[i] > data[j])
            {
                Swap(data[i], data[j]);
            }
        }
    }
    
    for (int i = 0; i < nCount; i++) {
        std::cout << data[i] << std::endl;
    }
}

// 快速排序
void QuickSort(int* array, int lfs, int rhs)
{
    if(lfs >= rhs) return;
    
    int left = lfs;
    int right = rhs;
    int key = array[left];
    
    while (left < right) {
        while (left < right && key <= array[right]) {
            right--;
        }
        array[left] = array[right];
        while (left < right && key >= array[left]) {
            left++;
        }
        array[right] = array[left];
    }
    array[left] = key;
    
    QuickSort(array, lfs, left-1);
    QuickSort(array, right+1, rhs);
    
}

// 希尔排序
void ShellSort(int* data, int len)
{
    int j, tmp;
    int gap = len;  // 增量
    do
    {
        gap = gap/3 + 1;
        
        for (int i = gap; i < len; i++) {
            if(data[i] < data[i - gap])
            {
                tmp = data[i];
                for (j = i - gap; j >= 0 && data[j] > tmp; j -= gap) {
                    data[j + gap] = data[j];
                }
                data[j + gap] = tmp;
            }
        }
    
    }while(gap > 1);
}

// 交换数组中的两个元素
void Swap(int *arr, int i, int j)
{
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

// 堆的调整
void HeapAdjust(int* arr, int node, int len)
{
    // node 是需要调整的节点 遍历节点的孩子 然后比较 和大的孩子交换位置
    for (int i = 2 * node; i < len; i *= 2)  // 说明有左孩子 但不一定有右孩子
    {
        int nodeIndex = i/2;
        int nodeValue = arr[nodeIndex];
        int maxChildIndex = i;
        
        if(i+1 < len)
        {
            // 说明有右孩子
            if(arr[i] < arr[i+1])
            {
                maxChildIndex++; // 找到大的孩子（右孩子）
            }
        }
        
        if(nodeValue >= arr[maxChildIndex]) continue;  // 说明节点比孩子大 则当前节点不需要调整
        
        arr[nodeIndex] = arr[maxChildIndex];           // 说明孩子比节点大 则交换
        arr[maxChildIndex] = nodeValue;
    }
}

// 对堆的排序
void HeapSort(int* arr, int len)
{
    for (int i = len/2; i > 0; i--) {    // 从后往前调整 叶子节点就不需要调整了
        HeapAdjust(arr, i, len);
    }
    
    // 上面的步骤调整完以后 第一个节点就是最大的
    
    for (int i = len - 1; i > 0; i--) {  // 把最大的一个元素放到最后 然后再调整堆 范围就是 [1 , lenth - i]
        Swap(arr, 1, i);  // 把最大的放到最后 然后把剩余的再重新调整
        HeapAdjust(arr, 1, i - 1);
    }
}


void Main()
{
//    InsertOrder();
//    BubbleOrder();
//    ExchangeOrder();
    
//    int a[] {70, 30, 20, 10, 60, 50, 90, 80, 40};
    int array[] {-1, 5, 7, 4, 8, 9, 11, 3, 43, 21, 33};
    HeapSort(array, 11);
    
//    QuickSort(array, 0, 10);
//    ShellSort(array, 11);
    
    for (int i = 0; i < 11; i++) {
        std::cout << array[i] << std::endl;
    }
}

NS_END

```