# Summary

* [简介](README.md)
* [第1章 预备知识](第1章 预备知识/1_0 第1章 预备知识.md)
    * [1.1 C++ 简介](第1章 预备知识/1_1 C++ 简介.md)
    * [1.2 C++ 简史](第1章 预备知识/1_2 C++简史.md)
        * [1.2.1 C 语言](第1章 预备知识/1_2_1 C 语言.md)
        * [1.2.2 C 语言编程原理](第1章 预备知识/1_2_2 C 语言编程原理.md)
        * [1.2.3 面向对象编程](第1章 预备知识/1_2_3 面向对象编程.md)
        * [1.2.4 C++ 和泛型编程](第1章 预备知识/1_2_4 C++ 和泛型编程.md)
        * [1.2.5 C++ 的起源](第1章 预备知识/1_2_5 C++ 的起源.md)
    * [1.3 可移植性和标准](第1章 预备知识/1_3 可移植性和标准.md)
        * [1.3.1 C++ 的发展](第1章 预备知识/1_3_1 C++ 的发展.md)
        * [1.3.2 本书遵循的 C++ 标准](第1章 预备知识/1_3_2 本书遵循的 C++ 标准.md)
    * [1.4 程序创建的技巧](第1章 预备知识/1_4 程序创建的技巧.md)
        * [1.4.1 创建源代码文件](第1章 预备知识/1_4_1 创建源代码文件.md)
        * [1.4.2 编译和链接](第1章 预备知识/1_4_2 编译和链接.md)
    * [1.5 总结](第1章 预备知识/1_5 总结.md)
* [第2章 开始学习  C++](第2章 开始学习  C++/2_0 开始学习 C++.md)
    * [2.1 进入 C++](第2章 开始学习  C++/2_1 进入 C++.md)
        * [2.1.1 main\(\) 函数](第2章 开始学习  C++/2_1_1 main 函数.md)
        * [2.1.2 C++ 注释](第2章 开始学习  C++/2_1_2 C++ 注释.md)
        * [2.1.3 C++ 预处理和 iostream 文件](第2章 开始学习  C++/2_1_3 C++ 预处理和 iostream 文件.md)
        * [2.1.4 头文件名](第2章 开始学习  C++/2_1_4 头文件名.md)
        * [2.1.5 名称空间](第2章 开始学习  C++/2_1_5 名称空间.md)
        * [2.1.6 使用 cout 进行 C++ 输出](第2章 开始学习  C++/2_1_6 使用 cout 进行 C++ 输出.md)
        * [2.1.7 C++ 源代码的格式化](第2章 开始学习  C++/2_1_7 C++ 源代码的格式化.md)
    * [2.2 C++ 语句](第2章 开始学习  C++/2_2 C++ 语句.md)
        * [2.2.1 声明语句和变量](第2章 开始学习  C++/2_2_1 声明语句的变量.md)
        * [2.2.2 赋值语句](第2章 开始学习  C++/2_2_2 赋值语句.md)
        * [2.2.3 cout 的新花样](第2章 开始学习  C++/2_2_3 cout 的新花样.md)
    * [2.3 其他 C++ 语句](第2章 开始学习  C++/2_3 其他 C++ 语句.md)
        * [2.3.1 使用 cin](第2章 开始学习  C++/2_3_1 使用 cin.md)
        * [2.3.2 使用 cout 进行拼接](第2章 开始学习  C++/2_3_2 使用 cout 进行拼接.md)
        * [2.3.3 类简介](第2章 开始学习  C++/233-类简介.md)
    * [2.4 函数](第2章 开始学习  C++/2_4 函数.md)
        * [2.4.1 使用有返回值的函数](第2章 开始学习  C++/2_4_1 使用有返回值的函数.md)
        * [2.4.2 函数变体](第2章 开始学习  C++/2_4_2 函数变体.md)
        * [2.4.3 用户定义的函数](第2章 开始学习  C++/2_4_3 用户定义的函数.md)
        * [2.4.4 用户定义的有返回值的函数](第2章 开始学习  C++/2_4_4 用户定义的有返回值的函数.md)
        * [2.4.5 在多函数程序中使用 using 编译指令](第2章 开始学习  C++/2_4_5 在多函数程序中使用 using 编译指令.md)
    * [2.5 总结](第2章 开始学习  C++/2_5 总结.md)
    * [2.6 复习题](第2章 开始学习  C++/2_6 复习题.md)
    * [2.7 编程练习](第2章 开始学习  C++/2_7 编程练习.md)
* [第3章 处理数据](第3章 处理数据/3_0 处理数据.md)
    * [3.1 简单变量](第3章 处理数据/3_1 简单变量.md)
        * [3.1.1 变量名](第3章 处理数据/3_1_1 变量名.md)
        * [3.1.2 整型](第3章 处理数据/3_1_2 整型.md)
        * [3.1.3 整型 short、int、long 和 long long](第3章 处理数据/3_1_3 整型 short、int、long 和 longlong.md)
        * [3.1.4 无符号类型](第3章 处理数据/3_1_4 无符号类型.md)
        * [3.1.5 选择整型类型](第3章 处理数据/3_1_5 选择整型类型.md)
        * [3.1.6 整型字面值](第3章 处理数据/3_1_6 整型字面值.md)
        * [3.1.7 C++ 如何确定常量的类型](第3章 处理数据/3_1_7 C++ 如何确定常量的类型.md)
        * [3.1.8 char 类型：字符和小整数](第3章 处理数据/3_1_8 char 类型：字符和小整数.md)
        * [3.1.9 bool 类型](第3章 处理数据/3_1_9 bool 类型.md)
    * [3.2 const 限定符](第3章 处理数据/3_2 const 限定符.md)
    * [3.3 浮点数](第3章 处理数据/3_3 浮点数.md)
        * [3.3.1 书写浮点数](第3章 处理数据/3_3_1 书写浮点数.md)
        * [3.3.2 浮点类型](第3章 处理数据/3_3_2 浮点类型.md)
        * [3.3.3 浮点常量](第3章 处理数据/3_3_3 浮点常量.md)
        * [3.3.4 浮点数的优缺点](第3章 处理数据/3_3_4 浮点数的优缺点.md)
    * [3.4 C++ 算术运算符](第3章 处理数据/3_4 C++ 算术运算符.md)
        * [3.4.1 运算符优先级和结合性](第3章 处理数据/3_4_1 运算符优先级和结合性.md)
        * [3.4.2 除法分支](第3章 处理数据/3_4_2 除法分支.md)
        * [3.4.3 求模运算符](第3章 处理数据/3_4_3 求模运算符.md)
        * [3.4.4 类型转换](第3章 处理数据/3_4_4 类型转换.md)
        * [3.4.5 C++11 中的 auto 声明](第3章 处理数据/3_4_5 C++11 中的 auto 声明.md)
    * [3.5 总结](第3章 处理数据/3_5 总结.md)
    * [3.6 复习题](第3章 处理数据/3_6 复习题.md)
    * [3.7 编程练习](第3章 处理数据/3_7 编程练习.md)
* [第4章 复合类型](第4章 复合类型/4_0 第4章 复合类型.md)
    * [4.1 数组](第4章 复合类型/4_1 数组.md)
        * [4.1.1 程序说明](第4章 复合类型/4_1_1 程序说明.md)
        * [4.1.2 数组的初始化规则](第4章 复合类型/4_1_2 数组的初始化规则.md)
        * [4.1.3 C++11 数组初始化方法](第4章 复合类型/4_1_3 C++11 数组初始化方法.md)
    * [4.2 字符串](第4章 复合类型/4_2 字符串.md)
        * [4.2.1 拼接字符串常量](第4章 复合类型/4_2_1 拼接字符串常量.md)
        * [4.2.2 在数组中使用字符串](第4章 复合类型/4_2_2 在数组中使用字符串.md)
        * [4.2.3 字符串输入](第4章 复合类型/4_2_3 字符串输入.md)
        * [4.2.4 每次读取一行字符串输入](第4章 复合类型/4_2_4 每次读取一行字符串输入.md)
        * [4.2.5 混合输入字符串和数字](第4章 复合类型/4_2_5 混合输入字符串和数字.md)
    * [4.3 string 类简介](第4章 复合类型/4_3 string 类简介.md)
        * [4.3.1 C++11 字符串初始化](第4章 复合类型/4_3_1 C++11 字符串初始化.md)
        * [4.3.2 赋值、拼接和附加](第4章 复合类型/4_3_2 赋值、拼接和附加.md)
        * [4.3.3 string 类的其他操作](第4章 复合类型/4_3_3 string 类的其他操作.md)
        * [4.3.4 string 类 I\/O](第4章 复合类型/4_3_4 string 类I_O.md)
        * [4.3.5 其他形式的字符串字面值](第4章 复合类型/4_3_5 其他形式的字符串字面值.md)
    * [4.4 结构简介](第4章 复合类型/4_4 结构简介.md)
        * [4.4.1 在程序中使用结构](第4章 复合类型/4_4_1 在程序中使用结构.md)
        * [4.4.2 C++11 结构初始化](第4章 复合类型/4_4_2 C++11 结构初始化.md)
        * [4.4.3 结构可以将 string 类作为成员吗](第4章 复合类型/4_4_3 结构可以将 string 类作为成员吗.md)
        * [4.4.4 其他结构属性](第4章 复合类型/4_4_4 其他结构属性.md)
        * [4.4.5 结构数组](第4章 复合类型/4_4_5 结构数组.md)
        * [4.4.6 结构中的位字段](第4章 复合类型/4_4_6 结构中的位字段.md)
    * [4.5 共用体](第4章 复合类型/4_5 共用体.md)
    * [4.6 枚举](第4章 复合类型/4_6 枚举.md)
        * [4.6.1 设置枚举量的值](第4章 复合类型/4_6_1 设置枚举量的值.md)
        * [4.6.2 枚举的取值范围](第4章 复合类型/4_6_2 枚举的取值范围.md)
    * [4.7 指针和自由存储空间](第4章 复合类型/4_7 指针和自由存储空间.md)
        * [4.7.1 声明和初始化指针](第4章 复合类型/4_7_1 声明和初始化指针.md)
        * [4.7.2 指针的危险](第4章 复合类型/4_7_2 指针的危险.md)
        * [4.7.3 指针和数字](第4章 复合类型/4_7_3 指针和数字.md)
        * [4.7.4 使用 new 来分配内存](第4章 复合类型/4_7_4 使用 new 来分配内存.md)
        * [4.7.5 使用 delete 释放内存](第4章 复合类型/4_7_5 使用 delete 释放内存.md)
        * [4.7.6 使用 new 来创建动态数组](第4章 复合类型/4_7_6 使用 new 来创建动态数组.md)
    * [4.8 指针、数组和指针算术](第4章 复合类型/4_8 指针、数组和指针算术.md)
        * [4.8.1 程序说明](第4章 复合类型/4_8_1 程序说明.md)
        * [4.8.2 指针小结](第4章 复合类型/4_8_2 指针小结.md)
        * [4.8.3 指针和字符串](第4章 复合类型/4_8_3 指针和字符串.md)
        * [4.8.4 使用 new 创建动态结构](第4章 复合类型/4_8_4 使用 new 创建动态结构.md)
        * [4.8.5 自动存储、静态存储和动态存储](第4章 复合类型/4_8_5 自动存储、静态存储和动态存储.md)
    * [4.9 类型组合](第4章 复合类型/4_9 类型组合.md)
    * [4.10 数组的替代品](第4章 复合类型/4_10 数组的替代品.md)
        * [4.10.1 模版类 vector](第4章 复合类型/4_10_1 模版类 vector.md)
        * [4.10.2 模版类 array（C++11）](第4章 复合类型/4_10_2 模版类 array（C11）.md)
        * [4.10.3 比较数组、vector 对象和 array 对象](第4章 复合类型/4_10_3 比较数组、vector 对象和 array 对象.md)
    * [4.11 总结](第4章 复合类型/4_11 总结.md)
    * [4.12 复习题](第4章 复合类型/4_12 复习题.md)
    * [4.13 编程练习](第4章 复合类型/4_13 编程练习.md)
* [第5章 循环和关系表达式](第5章 循环和关系表达式/5_0 循环和关系表达式.md)
    * [5.1 for 循环](第5章 循环和关系表达式/5_1 for 循环.md)
        * [5.1.1 for 循环的组成部分](第5章 循环和关系表达式/511-for-循环的组成部分.md)
        * [5.1.2 回到 for 循环](第5章 循环和关系表达式/512-回到-for-循环.md)
        * [5.1.3 修改步长](第5章 循环和关系表达式/513-修改步长.md)
        * [5.1.4 使用 for 循环访问字符串](第5章 循环和关系表达式/514-使用-for-循环访问字符串.md)
        * [5.1.5 递增运算符（++）和递减运算符（--）](第5章 循环和关系表达式/515-递增运算符（）和递减运算符（--）.md)
        * [5.1.6 副作用和顺序点](第5章 循环和关系表达式/516-副作用和顺序点.md)
        * [5.1.7 前缀格式和后缀格式](第5章 循环和关系表达式/517-前缀格式和后缀格式.md)
        * [5.1.8 递增／递减运算符和指针](第5章 循环和关系表达式/518-递增／递减运算符和指针.md)
        * [5.1.9 组合赋值运算符](第5章 循环和关系表达式/519-组合赋值运算符.md)
        * [5.1.10 复合语句（语句块）](第5章 循环和关系表达式/5110-复合语句（语句块）.md)
        * [5.1.11 其他语法技巧--逗号运算符](第5章 循环和关系表达式/5111-其他语法技巧--逗号运算符.md)
        * [5.1.12 关系表达式](第5章 循环和关系表达式/5112-关系表达式.md)
        * [5.1.13 赋值、比较和可能犯的错误](第5章 循环和关系表达式/5113-赋值、比较和可能犯的错误.md)
        * [5.1.14 C-风格字符串的比较](第5章 循环和关系表达式/5114-c-风格字符串的比较.md)
        * [5.1.15 比较 string 类字符串](第5章 循环和关系表达式/5115-比较-string-类字符串.md)
    * [5.2 while 循环](第5章 循环和关系表达式/52-while-循环.md)
        * [5.2.1 for 与 while](第5章 循环和关系表达式/521-for-与-while.md)
        * [5.2.2 等待一段时间：编写延时循环](第5章 循环和关系表达式/5_2_2 等待一段时间：编写延时循环.md)
    * [5.3 do while 循环](第5章 循环和关系表达式/53-do-while-循环.md)
    * [5.4 基于范围的 for 循环（C++11）](第5章 循环和关系表达式/54-基于范围的-for-循环（c11）.md)
    * [5.5 循环和文本输入](第5章 循环和关系表达式/55-循环和文本输入.md)
        * [5.5.1 使用原始的 cin 进行输入](第5章 循环和关系表达式/551-使用原始的-cin-进行输入.md)
        * [5.5.2 使用 cin.get \(char\) 进行补救](第5章 循环和关系表达式/552-使用-cinget-char-进行补救.md)
        * [5.5.3 使用哪一个 cin.get\(\)](第5章 循环和关系表达式/553-使用哪一个-cinget.md)
        * [5.5.4 文件尾条件](第5章 循环和关系表达式/554-文件尾条件.md)
        * [5.5.5 另一个 cin.get\(\) 版本](第5章 循环和关系表达式/555-另一个-cinget-版本.md)
    * [5.6 嵌套循环和二维数组](第5章 循环和关系表达式/56-嵌套循环和二维数组.md)
        * [5.6.1 初始化二维数组](第5章 循环和关系表达式/561-初始化二维数组.md)
        * [5.6.2 使用二维数组](第5章 循环和关系表达式/562-使用二维数组.md)
    * [5.7 总结](第5章 循环和关系表达式/57-总结.md)
    * [5.8 复习题](第5章 循环和关系表达式/58-复习题.md)
    * [5.9 编程练习](第5章 循环和关系表达式/59-编程练习.md)
* [第6章 分支语句和逻辑运算符](第6章 分支语句和逻辑运算符/6_0 分支语句和逻辑运算符.md)
    * [6.1 if 语句](第6章 分支语句和逻辑运算符/61-if-语句.md)
        * [6.1.1 ifelse 语句](第6章 分支语句和逻辑运算符/611-ifelse-语句.md)
        * [6.1.2 格式化 ifelse 语句](第6章 分支语句和逻辑运算符/612-格式化-ifelse-语句.md)
        * [6.1.3 ifelse ifelse 结构](第6章 分支语句和逻辑运算符/613-ifelse-ifelse-结构.md)
    * [6.2 逻辑表达式](第6章 分支语句和逻辑运算符/62-逻辑表达式.md)
        * [6.2.1 逻辑 OR 运算符：||](第6章 分支语句和逻辑运算符/621-逻辑-or-运算符：.md)
        * [6.2.2 逻辑 AND 运算符：&&](第6章 分支语句和逻辑运算符/622-逻辑-and-运算符：.md)
        * [6.2.3 用 && 来设置取值范围](第6章 分支语句和逻辑运算符/623-用--来设置取值范围.md)
        * [6.2.4 逻辑 NOT 运算符：！](第6章 分支语句和逻辑运算符/624-逻辑-not-运算符：！.md)
        * [6.2.5 逻辑运算符细节](第6章 分支语句和逻辑运算符/625-逻辑运算符细节.md)
        * [6.2.6 其他表示方式](第6章 分支语句和逻辑运算符/626-其他表示方式.md)
    * [6.3 字符函数库 cctype](第6章 分支语句和逻辑运算符/63-字符函数库-cctype.md)
    * [6.4 ? : 运算符](第6章 分支语句和逻辑运算符/64---运算符.md)
    * [6.5 switch 语句](第6章 分支语句和逻辑运算符/65-switch-语句.md)
        * [6.5.1 将枚举量用作标签](第6章 分支语句和逻辑运算符/651-将枚举量用作标签.md)
        * [6.5.2 switch 和 ifelse](第6章 分支语句和逻辑运算符/652-switch-和-ifelse.md)
    * [6.6 break 和 continue 语句](第6章 分支语句和逻辑运算符/66-break-和-continue-语句.md)
    * [6.7 读取数字的循环](第6章 分支语句和逻辑运算符/67-读取数字的循环.md)
    * [6.8 简单文件输入／输出](第6章 分支语句和逻辑运算符/68-简单文件输入／输出.md)
        * [6.8.1 文本 I\/O 和文本文件](第6章 分支语句和逻辑运算符/681-文本-io-和文本文件.md)
        * [6.8.2 写入到文本文件中](第6章 分支语句和逻辑运算符/682-写入到文本文件中.md)
        * [6.8.3 读取文本文件](第6章 分支语句和逻辑运算符/683-读取文本文件.md)
    * [6.9 总结](第6章 分支语句和逻辑运算符/69-总结.md)
    * [6.10 复习题](第6章 分支语句和逻辑运算符/610-复习题.md)
    * [6.11 编程练习](第6章 分支语句和逻辑运算符/611-编程练习.md)
* [第7章 函数--C++ 的编程模块](第7章 函数--C++ 的编程模块/7_0 函数--C++的编程模块.md)
    * [7.1 复习函数的基本知识](第7章 函数--C++ 的编程模块/7_1 复习函数的基本知识.md)
        * [7.1.1 定义函数](第7章 函数--C++ 的编程模块/7_1_1 定义函数.md)
        * [7.1.2 函数原型和函数调用](第7章 函数--C++ 的编程模块/7_1_2 函数原型和函数调用.md)
    * [7.2 函数参数和按值传递](第7章 函数--C++ 的编程模块/7_2 函数参数和按值传递.md)
        * [7.2.1 多个参数](第7章 函数--C++ 的编程模块/7_2_1 多个参数.md)
        * [7.2.2 另外一个接受两个参数的函数](第7章 函数--C++ 的编程模块/7_2_2 另外一个接受两个参数的函数.md)
    * [7.3 函数和数组](第7章 函数--C++ 的编程模块/7_3 函数和数组.md)
        * [7.3.1 函数如何使用指针来处理数组](第7章 函数--C++ 的编程模块/7_3_1 函数如何使用指针来处理数组.md)
        * [7.3.2 将数组作为参数意味着什么](第7章 函数--C++ 的编程模块/7_3_2 将数组作为参数意味着什么.md)
        * [7.3.3 更多数组函数示例](第7章 函数--C++ 的编程模块/7_3_3 更多数组函数示例.md)
        * [7.3.4 使用数组区间的函数](第7章 函数--C++ 的编程模块/7_3_4 使用数组区间的函数.md)
        * [7.3.5 指针和 const](第7章 函数--C++ 的编程模块/7_3_5 指针和 const.md)
    * [7.4 函数和二维数组](第7章 函数--C++ 的编程模块/7_4 函数和二维数组.md)
    * [7.5 函数和 C- 风格字符串](第7章 函数--C++ 的编程模块/7_5 函数和 C- 风格字符串.md)
        * [7.5.1 将 C- 风格字符串作为参数的函数](第7章 函数--C++ 的编程模块/7_5_1 将 C- 风格字符串作为参数的函数.md)
        * [7.5.2 返回 C- 风格字符串的函数](第7章 函数--C++ 的编程模块/7_5_2 返回 C- 风格字符串的函数.md)
    * [7.6 函数和结构](第7章 函数--C++ 的编程模块/7_6 函数和结构.md)
        * [7.6.1 传递和返回结构](第7章 函数--C++ 的编程模块/7_6_1 传递和返回结构.md)
        * [7.6.2 另一个处理结构的函数示例](第7章 函数--C++ 的编程模块/7_6_2 另一个处理结构的函数示例.md)
        * [7.6.3 传递结构的地址](第7章 函数--C++ 的编程模块/7_6_3 传递结构的地址.md)
    * [7.7 函数和 string 对象](第7章 函数--C++ 的编程模块/7_7 函数和 string 对象.md)
    * [7.8 函数与 array 对象](第7章 函数--C++ 的编程模块/7_8 函数与 array 对象.md)
    * [7.9 递归](第7章 函数--C++ 的编程模块/7_9 递归.md)
        * [7.9.1 包含一个递归调用的递归](第7章 函数--C++ 的编程模块/7_9_1 包含一个递归调用的递归.md)
        * [7.9.2 包含多个递归调用的递归](第7章 函数--C++ 的编程模块/7_9_2 包含多个递归调用的递归.md)
    * [7.10 函数指针](第7章 函数--C++ 的编程模块/7_10 函数指针.md)
        * [7.10.1 函数指针的基础知识](第7章 函数--C++ 的编程模块/7_10_1 函数指针的基础知识.md)
        * [7.10.2 函数指针示例](第7章 函数--C++ 的编程模块/7_10_2 函数指针示例.md)
        * [7.10.3 深入探讨函数指针](第7章 函数--C++ 的编程模块/7_10_3 深入探讨函数指针.md)
        * [7.10.4 使用 typedef 进行简化](第7章 函数--C++ 的编程模块/7_10_4 使用 typedef 进行简化.md)
    * [7.11 总结](第7章 函数--C++ 的编程模块/7_11 总结.md)
    * [7.12 复习题](第7章 函数--C++ 的编程模块/7_12 复习题.md)
    * [7.13 编程练习](第7章 函数--C++ 的编程模块/7_13 编程练习.md)
* [第8章 函数探幽](第8章-函数探幽.md)
    * 8.1 C++ 内联函数
    * 8.2 引用变量
        * 8.2.1 创建引用变量
        * 8.2.2 将引用用作函数参数
        * 8.2.3 引用的属性和特别之处
        * 8.2.4 将引用用于结构
        * 8.2.5 将引用用于类对象
        * 8.2.6 对象、继承和引用
        * 8.2.7 何时使用引用参数
    * 8.3 默认参数
    * 8.4 函数重载
        * 8.4.1 重载示例
        * 8.4.2 何时使用函数重载
    * 8.5 函数模版
        * 8.5.1 重载的模版
        * 8.5.2 模版的局限性
        * 8.5.3 显式具体化
        * 8.5.4 实例化和具体化
        * 8.5.5 编译器选择使用哪个函数版本
        * 8.5.6 模版函数的发展
    * 8.6 总结
    * 8.7 复习题
    * 8.8 编程练习
* [第9章 内存模型和名称空间](第9章 内存模型和名称空间/9_0 内存模型和名称空间.md)
    * [9.1 单独编译](第9章 内存模型和名称空间/91-单独编译.md)
    * [9.2 存储持续性、作用域和链接性](第9章 内存模型和名称空间/92-存储持续性、作用域和链接性.md)
        * [9.2.1 作用域和链接](第9章 内存模型和名称空间/921-作用域和链接.md)
        * [9.2.2 自动存储持续性](第9章 内存模型和名称空间/922-自动存储持续性.md)
        * 9.2.3 静态持续变量
        * 9.2.4 静态持续性、外部链接性
        * 9.2.5 静态持续性、内部链接性
        * 9.2.6 静态存储持续性、无链接性
        * 9.2.7 说明符和限定符
        * 9.2.8 函数和链接性
        * 9.2.9 语言链接性
        * 9.2.10 存储方案和动态分配
    * 9.3 名称空间
        * 9.3.1 传统的 C++ 名称空间
        * 9.3.2 新的名称空间特性
        * 9.3.3 名称空间示例
        * 9.3.4 名称空间及其前途
    * 9.4 总结
    * 9.5 复习题
    * 9.6 编程练习
* [第10章 对象和类](第10章 对象和类/10_0 对象和类.md)
    * [10.1 过程性编程和面向对象编程](第10章 对象和类/10_1 过程性编程和面向对象编程.md)
    * [10.2 抽象和类](第10章 对象和类/102-抽象和类.md)
        * [10.2.1 类型是什么](第10章 对象和类/1021-类型是什么.md)
        * [10.2.2 C++ 中的类](第10章 对象和类/1022-c-中的类.md)
        * [10.2.3 实现类成员函数](第10章 对象和类/1023-实现类成员函数.md)
        * [10.2.4 使用类](第10章 对象和类/1024-使用类.md)
        * [10.2.5 修改实现](第10章 对象和类/1025-修改实现.md)
        * [10.2.6 小结](第10章 对象和类/1026-小结.md)
    * [10.3 类的构造函数和析构函数](第10章 对象和类/103-类的构造函数和析构函数.md)
        * 10.3.1 声明和定义构造函数
        * 10.3.2 使用构造函数
        * 10.3.3 默认构造函数
        * 10.3.4 析构函数
        * 10.3.5 改进 Stock 类
        * 10.3.6 构造函数和析构函数小结
    * [10.4 this 指针](第10章 对象和类/104-this-指针.md)
    * [10.5 对象数组](第10章 对象和类/105-对象数组.md)
    * [10.6 类作用域](第10章 对象和类/106-类作用域.md)
        * [10.6.1 作用域为类的常量](第10章 对象和类/1061-作用域为类的常量.md)
        * [10.6.2 作用域内枚举（C++11）](第10章 对象和类/1062-作用域内枚举（c11）.md)
    * [10.7 抽象数据类型](第10章 对象和类/107-抽象数据类型.md)
    * [10.8 总结](第10章 对象和类/108-总结.md)
    * [10.9 复习题](第10章 对象和类/109-复习题.md)
    * [10.10 编程练习](第10章 对象和类/1010-编程练习.md)
* [第11章 使用类](第11章-使用类.md)
    * 11.1 运算符重载
    * 11.2 计算时间：一个运算符重载示例
        * 11.2.1 添加加法运算符
        * 11.2.2 重载限制
        * 11.2.3 其他重载运算符
    * 11.3 友元
        * 11.3.1 创建友元
        * 11.3.2 常用的友元：重载 &lt;&lt; 运算符
    * 11.4 重载运算符：作为成员函数还是非成员函数
    * 11.5 再谈重载：一个矢量类
        * 11.5.1 使用状态成员
        * 11.5.2 为 Vector 类重载算术运算符
        * 11.5.3 对实现的说明
        * 11.5.4 使用 Vector 类来模拟随机漫步
    * 11.6 类的自动转换和强制类型转换
        * 11.6.1 转换函数
        * 11.6.2 转换函数和友元函数
    * 11.7 总结
    * 11.8 复习题
    * 11.9 编程练习
* 第12章 类和动态内存分配
    * 12.1 动态内存和类
        * 12.1.1 复习示例和静态类成员
        * 12.1.2 特殊成员函数
        * 12.1.3 回到 Stringbad：复制构造函数的哪里出了问题
        * 12.1.4 Stringbad 的其他问题：赋值运算符
    * 12.2 改进后的新 String 类
        * 12.2.1 修订后的默认构造函数
        * 12.2.2 比较成员函数
        * 12.2.3 使用中括号表示法访问字符
        * 12.2.4 静态类成员函数
        * 12.2.5 进一步重载赋值运算符
    * [12.3 在构造函数中使用 new 时应注意的事项](123-在构造函数中使用-new-时应注意的事项.md)
        * 12.3.1 应该和不应该
        * 12.3.2 包含类成员的类的逐成员复制
    * 12.4 有关返回对象的说明
        * 12.4.1 返回指向 const 对象的引用
        * 12.4.2 返回指向非 const 对象的引用
        * 12.4.3 返回对象
        * 12.4.4 返回 const 对象
    * 12.5 使用指向对象的指针
        * 12.5.1 再谈 new 和 delete
        * 12.5.2 指针和对象小结
        * 12.5.3 再谈定位 new 运算符
    * 12.6 复习各种技术
        * 12.6.1 重载 &lt;&lt; 运算符
        * 12.6.2 转换函数
        * 12.6.3 其构造函数使用 new 的类
    * 12.7 队列模拟
        * 12.7.1 队列类
        * 12.7.2 Customer 类
        * 12.7.3 ATM 模拟
    * 12.8 总结
    * 12.9 复习题
    * 12.10 编程练习
* 第13章 类继承
    * 13.1 一个简单的基类
        * 13.1.1 派生一个类
        * 13.1.2 构造函数：访问权限的考虑
        * 13.1.3 使用派生类
        * 13.1.4 派生类和基类之间的特殊关系
    * 13.2 继承：is-a 关系
    * 13.3 多态公有继承
    * 13.4 静态联编和动态联编
        * 13.4.1 指针和引用类型的兼容性
        * 13.4.2 虚成员函数和动态联编
        * 13.4.3 有关虚函数注意事项
    * 13.5 访问控制：protected
    * 13.6 抽象基类
        * 13.6.1 应用 ABC 概念
        * 13.6.2 ABC 理念
    * 13.7 继承和动态分配内存
        * 13.7.1 第一种情况：派生类不使用 new
        * 13.7.2 第二种情况：派生类使用 new
        * 13.7.3 使用动态内存分配和友元的继承示例
    * 13.8 类设计回顾
        * 13.8.1 编译器生成的成员函数
        * 13.8.2 其他的类方法
        * 13.8.3 公有继承的考虑因素
        * 13.8.4 类函数小结
    * 13.9 总结
    * 13.10 复习题
    * 13.11 编程练习
* 第14章 C++ 中的代码重用
    * 14.1 包含对象成员的类
        * 14.1.1 valarray 类简介
        * 14.1.2 Student 类的设计
        * 14.1.3 Student 类示例
    * 14.2 私有继承
        * 14.2.1 Student 类示例（新版本）
        * 14.2.2 使用包含还是私有继承
        * 14.2.3 保护继承
        * 14.2.4 使用 using 重新定义访问权限
    * 14.3 多重继承
        * 14.3.1 有多少 Worker
        * 14.3.2 哪个方法
        * 14.3.3 MI 小结
    * 14.4 类模版
        * 14.4.1 定义类模版
        * 14.4.2 使用模版类
        * 14.4.3 深入探讨模版类
        * 14.4.4 数组模版示例和非类型参数
        * 14.4.5 模版多功能性
        * 14.4.6 模版的具体化
        * 14.4.7 成员模版
        * 14.4.8 将模版用作参数
        * 14.4.9 模版类和友元
        * 14.4.10 模版别名（C++11）
    * 14.5 总结
    * 14.6 复习题
    * 14.7 编程练习
* 第15章 友元、异常和其他
    * 15.1 友元
        * 15.1.1 友元类
        * 15.1.2 友元成员函数
        * 15.1.3 其他友元关系
        * 15.1.4 共同的友元
    * 15.2 嵌套类
        * 15.2.1 嵌套类和访问权限
        * 15.2.2 模版中的嵌套
    * 15.3 异常
        * 15.3.1 调用 abort\(\)
        * 15.3.2 返回错误码
        * 15.3.3 异常机制
        * 15.3.4 将对象用作异常类型
        * 15.3.5 异常规范和 C++11
        * 15.3.6 栈解退
        * 15.3.7 其他异常特性
        * 15.3.8 exception 类
        * 15.3.9 异常、类和继承
        * 15.3.10 异常何时会迷失方向
        * 15.3.11 有关异常的注意事项
    * 15.4 RTTI
        * 15.4.1 RTTI 的用途
        * 15.4.2 RTTI 的工作原理
    * 15.5 类型转换运算符
    * 15.6 总结
    * 15.7 复习题
    * 15.8 编程练习
* [第16章 string 类和标准模版库](第16章 string 类和标准模版库/第16章-string-类和标准模版库.md)
    * [16.1 string 类](第16章 string 类和标准模版库/161-string-类.md)
        * [16.1.1 构造字符串](第16章 string 类和标准模版库/1611-构造字符串.md)
        * [16.1.2 string 类输入](第16章 string 类和标准模版库/1612-string-类输入.md)
        * [16.1.3 使用字符串](第16章 string 类和标准模版库/1613-使用字符串.md)
        * [16.1.4 string 还提供了哪些功能](第16章 string 类和标准模版库/1614-string-还提供了哪些功能.md)
        * [16.1.5 字符串种类](第16章 string 类和标准模版库/1615-字符串种类.md)
    * [16.2 智能指针模版类](第16章 string 类和标准模版库/162-智能指针模版类.md)
        * 16.2.1 使用智能指针
        * 16.2.2 有关智能指针的注意事项
        * 16.2.3 unique\_ptr 为何优于 auto\_ptr
        * 16.2.4 选择智能指针
    * [16.3 标准模版库](第16章 string 类和标准模版库/163-标准模版库.md)
        * [16.3.1 模版类 vector](第16章 string 类和标准模版库/1631-模版类-vector.md)
        * [16.3.2 可对矢量执行的操作](第16章 string 类和标准模版库/1632-可对矢量执行的操作.md)
        * [16.3.3 对矢量可执行的其他操作](第16章 string 类和标准模版库/1633-对矢量可执行的其他操作.md)
        * [16.3.4 基于范围的 for 循环（C++11）](第16章 string 类和标准模版库/1634-基于范围的-for-循环（c11）.md)
    * [16.4 泛型编程](第16章 string 类和标准模版库/164-泛型编程.md)
        * 16.4.1 为何使用迭代器
        * 16.4.2 迭代器类型
        * [16.4.3 迭代器层次结构](第16章 string 类和标准模版库/1643-迭代器层次结构.md)
        * [16.4.4 概念、改进和模型](第16章 string 类和标准模版库/1644-概念、改进和模型.md)
        * [16.4.5 容器种类](第16章 string 类和标准模版库/1645-容器种类.md)
        * [16.4.6 容器种类](第16章 string 类和标准模版库/1646-容器种类.md)
        * [16.4.7 无序关联容器（C++11）](第16章 string 类和标准模版库/1647-无序关联容器（c11）.md)
    * 16.5 函数对象
        * 16.5.1 函数符概念
        * 16.5.2 预定义的函数符
        * 16.5.3 自适应函数符和函数适配器
    * 16.6 算法
        * 16.6.1 算法组
        * 16.6.2 算法的通用特征
        * 16.6.3 STL 和 string 类
        * 16.6.4 函数和容器方法
        * 16.6.5 使用 STL
    * 16.7 其他库
        * 16.7.1 vector、valarray 和 array
        * 16.7.2 模版 initializer\_list（C++11）
        * 16.7.3 使用 initializer\_list
    * 16.8 总结
    * 16.9 复习题
    * 16.10 编程练习
* [第17章 输入、输出和文件](第17章-输入、输出和文件.md)
    * 17.1 C++ 输入和输出概述
        * 17.1.1 流和缓冲区
        * 17.1.2 流、缓冲区和 iostream 文件
        * 17.1.3 重定向
    * 17.2 使用 cout 进行输出
        * 17.2.1 重载的 &lt;&lt; 运算符
        * 17.2.2 其他 ostream 方法
        * 17.2.3 刷新输出缓冲区
        * 17.2.4 用 cout 进行格式化
    * 17.3 使用 cin 进行输入
        * 17.3.1 cin &gt;&gt; 如何检查输入
        * 17.3.2 流状态
        * 17.3.3 其他 istream 类方法
        * 17.3.4 其他 istream 方法
    * 17.4 文件输入和输出
        * 17.4.1 简单的文件 I\/O
        * 17.4.2 流状态检查和 is\_open\(\)
        * 17.4.3 打开多个文件
        * 17.4.4 命令行处理技术
        * 17.4.5 文件模式
        * 17.4.6 随机存取
    * 17.5 内核格式化
    * 17.6 总结
    * 17.7 复习题
    * 17.8 编程练习
* [第18章 探讨 C++ 新标准](第18章-探讨-c-新标准.md)
    * [18.1 复习前面介绍过的 C++11 功能](181-复习前面介绍过的-c11-功能.md)
        * [18.1.1 新类型](1811-新类型.md)
        * [18.1.2 统一的初始化](1812-统一的初始化.md)
        * [18.1.3 声明](1813-声明.md)
        * [18.1.4 智能指针](1814-智能指针.md)
        * [18.1.5 异常规范方面的修改](1815-异常规范方面的修改.md)
        * [18.1.6 作用域内枚举](1816-作用域内枚举.md)
        * [18.1.7 对类的修改](1817-对类的修改.md)
        * [18.1.8 模版和 STL 方面的修改](1818-模版和-stl-方面的修改.md)
        * [18.1.9 右值引用](1819-右值引用.md)
    * [18.2 移动语义和右值引用](182-移动语义和右值引用.md)
        * 18.2.1 为何需要移动语义
        * 18.2.2 一个移动示例
        * 18.2.3 移动构造函数解析
        * 18.2.4 赋值
        * 18.2.5 强制移动
    * [18.3 新的类功能](183-新的类功能.md)
        * 18.3.1 特殊的成员函数
        * 18.3.2 默认的方法和禁用的方法
        * 18.3.3 委托构造函数
        * 18.3.4 继承构造函数
        * 18.3.5 管理虚方法：override 和 final
    * [18.4 Lambda 函数](184-lambda-函数.md)
        * 18.4.1 比较函数指针、函数符和 Lambda 函数
        * 18.4.2 为何使用 lambda
    * [18.5 包装器](185-包装器.md)
        * 18.5.1 包装器 function 及模版的低效性
        * 18.5.2 修复问题
        * 18.5.3 其他方式
    * [18.6 可变参数模版](186-可变参数模版.md)
        * 18.6.1 模版和函数参数包
        * 18.6.2 展开参数包
        * 18.6.3 在可变参数模版函数中使用递归
    * [18.7 C++11 新增的其他功能](187-c11-新增的其他功能.md)
        * 18.7.1 并行编程
        * 18.7.2 新增的库
        * 18.7.3 低级编程
        * 18.7.4 杂项
    * [18.8 语言变化](188-语言变化.md)
        * 18.8.1 Boost 项目
        * 18.8.2 TR1
        * 18.8.3 使用 Boost
    * 18.9 接下来的任务
    * 18.10 总结
    * 18.11 复习题
    * [18.12 编程练习](1812-编程练习.md)

